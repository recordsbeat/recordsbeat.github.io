---
title: "새벽의 정리"
date: 2020-04-06 01:16:00 -0400
categories: mainthought
---

첫번째,


api의 이름은 어떻게 지어야 할까?(api의 기준은 어떻게 나누어질까?)


링크

https://www.popit.kr/%ec%a2%8c%ec%b6%a9%ec%9a%b0%eb%8f%8c-api-%ed%95%a8%ec%88%98-%ec%9d%b4%eb%a6%84%ec%9d%80-%ec%96%b4%eb%96%bb%ea%b2%8c-%ec%a7%93%eb%8a%94%ea%b2%8c-%ec%a2%8b%ec%9d%84%ea%b9%8c/?fbclid=IwAR3sxEW1Wp25vHJ30CoxyLfrlKCaivwfdl__F6Zw2Z-w9KBjnhiFnyGQLi0


위 링크는 api의 작명에 따라 기능을 분류하는 부분에 대해 설명한다.

대표적으로 사용자의 행위 따른 분류와 CRUD에 따른 분류를 이야기 다음과 같은 코멘트를 남긴다.



CRUD 함수 이름을 활용해 API 함수 이름 짓기할 때

-UpdateStatus 라는 이름은 데이터베이스에 저장된 상태값을 변경하는 행위를 나타내는데 사용자 행위를 나타내기엔 표현법이 부족하다.

-표현법이 부족함으로 인해 행위를 결정짓기 위해 구체적인 상태값을 파라미터로 전달해줘야 한다.

-전달된 파라미터의 유효성을 검사하기 위한 중첩된 if문이 발생할 여지가 생긴다.

-변경을 어렵게 하는 요소가 된다

-외부에서 전달받은 파라미터로 행위가 결정되기 때문에 소통시 S, R 등등과 같은 개발코드에 기반한 소통을 할 여지가 생긴다.

-구성원간의 소통을 어렵게 하는 요소가 된다.

사용자 행위를 API 함수 이름 짓기에 사용할 때

-개발자와 업무전문가가 함께 이해할 수 있는 비즈니스 용어로 소통할 수 있다.

-외부에 노출되는 행위만 유지한 다면 모델 내부의 함수로직을 변경하는데 제약이 없다.

-새로운 비지니스 요구사항이 추가 되었을 때 변경에 용이하다.



현재 개발하고 있는 프로젝트의 문제점과 상당히 일치한다.

CRUD상으로 구현된 api는 상당히 많은 부분의 절차를 검사해야하므로 if의 중첩이 무분별하게 발생하며

상태값에 따른 해석이 어려워지기 시작한다.


이를 피하기 위해 얼마전까지 ENUM을 활용한 리펙토링 방안에 대해 생각하고 작성하였는데

애시당초 사용자 행위에 따른 api로 재설계된다면 클라이언트로부터 status를 enum 파라미터로 받아 분기태우는 일 자체가 없어진다는 것이다.
ex) update trip -> passengerGetOff
이는 저번에 작성하였던 정산 페이지에 대한 구현을 다시 한 번 생각하게 하였고 고쳐볼 생각이다.
<br>
<br>
<br>
두번째,
<br>
<br>
<br>
참고링크<br>
<br>
https://philipbox.tistory.com/78
<br>
이동욱님의 책에서 본 내용을 찾다보니 우연치 않게 같은 내용의 링크를 찾게 되었다.

일단 내용은 이러하다.

개발자들이 많이들 하는 오해가 service단에서 비지니스 처리를 해야된다는 것이다.

그래서 서비스 쪽에서 많은 DB탐색과 데이터 정제가 이루어지곤 한다.

하지만 이는 틀린 내용이었던 것.

비지니스 처리는 도메인에서 진행되어야 한다. 가령 주문을 완료한다거나 배송을 시작한다거나..

order domain 내에 completeOrder 내지 startDelivery 같은..

그러면서 서비스단에서의 처리는 각 도메인(데이터베이스)의 내용들이 일관된 처리르 할 수 있도록 전체적인 플로우를 잡아주는 것이다.

(completeOrder 하려면 결제를 완료시켜야된다거나..하는)

이 부분 역시 지금 내가 만든 프로젝트에서 잘못된 부분.

정산페이지 작업 내용 중 애초에 domain에 대한 개념을 잘못 잡았다.

테이블과 매칭되는 객체를 domain으로 잡고 join되는 데이터들은 collection과 같은 기능을 이용해 가져오는 것이 맞을터.

이 부분도 리펙토링이 필요하다.

(첫번째 내용과 두번째 내용은 어떻게보면 비슷하다. 도메인 자체에서 각 비지니스에 대한 행위를 처리하고 서비스단에서 일관성을 맞춰줄 수 있도록 해야한다.

CRUD로 이루어진 서비스인 경우 이 행위 처리에 대한 경계가 모호해질 수 있다.)
<br>
<br>
<br>
<br>
<br>
세번째

주말 간 서점에서 '동료들 뒷목 잡게 하는 나쁜 프로그래밍 습관'이란 책을 읽었다.

이 책에서 기억에 남는 부분.

-반복되는 if보단 차리리 swith case 가 낫다. 

-foreach는 객체의 모든 내용을 메모리에 올리고 시작한다. 파일을 읽는 io 행위는 while 문이 적합하다

-반복문의 로직을 되도록 stream,filter,map 을 사용해 내용을 최소화한다.

위 내용들은 내가 기억하기 편하도록 정제(?)되었다.

-반복되는 if보단 차리리 swith case 가 낫다. 

이 부분은 if else를 여러번 분기 태우기 시작하면 각 조건 문 마다 참/거짓을 판별하고 다음 알고리즘 단계로 넘어가야되는 구조에 대해 이야기했다.

한 번의 분기뎁스로 지나칠 수 있는 것을 무분별한 if문을 사용시에 불필요한 참조를 계속 만들어내는 것이다.

<br>
<br>
<br>

-foreach는 객체의 모든 내용을 메모리에 올리고 시작한다. 파일을 읽는 io 행위는 while 문이 적합하다.

for, while, foreach 에 대해 어떤 방식을 사용하는 것이 적절한가에 대해 이야기하였는데.

for와 while은 무한 루프에 빠질 수 있기에 반복범위나 예외 케이스에 대해 주의 깊게 생각하고 사용해야 되는 것은 맞다.

그러고 foreach 반복문은 시작할 때 대상 객체를 메모리에 올리고 시작한다. 가령 대용량 파일을 읽으면 그걸 메모리에 몽땅 올리는 불상사가 발생한다.

해서 파일을 읽는 상황같은 때는 한줄씩 메모리에 얹어 쓸 수 있는 while문이 적당하다고 한다.

나는 당연히 foreach가 많이 쓰여서 좋은 것인 줄 알았다...ㅜㅜ

<br><br><br>

마지막 네번째

갓배민은 항상 좋은 내용을 공유해준다.(오픈소스나 강의자료로)

그 중 제네릭을 사용한 공통 메소드를 살펴봤다. 이전까진 제네릭 사용법에 대해 거의 몰랐다가 이번 기회에 짧막하게 찾아보았다.

특히 와일드카드 표기법에 대해 잘 알게 되었다.

참고링크

https://medium.com/@joongwon/java-java%EC%9D%98-generics-604b562530b3

https://preamtree.tistory.com/138


제네릭은 여러클래스를 일관된 형태로 컨트롤하기위해 사용한다라고 생각하게 되었다.

기회가 되면 무조건 써보고 싶다.

뭔가 인터페이스를 사용하고 제네릭형태로 공통 메소드를 짜본다면 + stream을 잘사용해본다면

나름 요즘 코딩(?)에 부합하지 않을까 라는 생각을 해본다.


월요일에 무엇을 다시 시작할까 생각하며 쓴 글 마무리..


